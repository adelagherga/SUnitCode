//SplitPrimePropertiesXYZ2.m

/*
INPUT:
    I:= [[p_1, h_1, P_1],...,[p_n, h_n, P_n]], where
        p_i:= prime of S which splits in K
        h_i:= smallest positive integer such that P^(h_i) = (pi) is principal, where P lies above p in K
        P_i:= (unique) choice of prime ideal in K lying above p
    corresponds to the set I of primes that split in K such that a_i > b_i
        ie. { i | 1 <= i <= t, a_i > b_i}
        
    I_:= [[p_1, h_1, P_1],...,[p_n, h_n, P_n]], where
        p_i:= prime of S which splits in K
        h_i:= smallest positive integer such that P^(h_i) = (pi) is principal, where P lies above p in K
        P_i:= (unique) choice of prime ideal in K lying above p
    corresponds to the set I_ of primes that split in K such that a_i < b_i
        ie. { i | 1 <= i <= t, a_i < b_i}
            
    D:= squarefree part of x, where
        x:= Du^2 and x + y = z^2

OUTPUT:
    Qi:= [[p_1, h_1, pi_1, (pi_)_1, P_1],...,[p_n, h_n, pi_n, (pi_)_n, P_n]], where
        p_i:= prime of S which splits in K
        h_i:= smallest positive integer such that P^(h_i) = (pi) is principal, where P lies above p in K
        pi_i:= generator of the ideal P^(h_i) = (pi)R, chosen so that Abs(pi) > Abs(pi_)
        (pi_)_i:= conjugate of pi, chosen so that Abs(pi) > Abs(pi_)
        P_i:= (unique) choice of prime ideal in K lying above p

    Qi_:= [[p_1, h_1, pi_1, (pi_)_1, P_1],...,[p_n, h_n, pi_n, (pi_)_n, P_n]], where
        p_i:= prime of S which splits in K
        h_i:= smallest positive integer such that P^(h_i) = (pi) is principal, where P lies above p in K
        pi_i:= generator of the ideal P^(h_i) = (pi)R, chosen so that Abs(pi) < Abs(pi_)
        (pi_)_i:= conjugate of pi, chosen so that Abs(pi) < Abs(pi_)
        P_i:= (unique) choice of prime ideal in K lying above p
                
COMMENTS:
    Computes pi and its conjugate, pi_, in K = Q(Sqrt(D)), where
        P^(h_i) = (pi)R
    for P lying above p in S, according to whether P is in I or I_
    These elements are determined up to multiplication by a unit, hence are chosen so that
        Abs(pi) > Abs(pi_) if P is in I, P^(h_i) = (pi)R
        Abs(pi) < Abs(pi_) if P is in I_, P^(h_i) = (pi)R

    This result is used to compute u:= G_{alpha}, and subsequently (x,y,z)

REFERENCE:
    B.M.M.De Weger. Algorithms For Diophantine Equations. PhD thesis, University of Leiden, 1988.

EXAMPLE:
    > S:= [2,3,11,23];
    > D:= 253;   
    > b0, SplitPrimes, NonSplitPrimes:= DecompositionOfPrimesXYZ2(S,D);  
    > SplitPrimes;
    [
        <3, 1, Principal Prime Ideal
        Generator:
            -2*$.2 - 15>
    ]
    > I:= [SplitPrimes[1]];
    > I_:= [];
    > Qi,Qi_:= SplitPrimePropertiesXYZ2(I,I_,D);
    > Qi;
    [
        <3, 1, -sqrtD - 16, sqrtD - 16, Principal Prime Ideal
        Generator:
            -2*$.2 - 15>
    ]
    > Qi_;
    []

*/


function SplitPrimePropertiesXYZ2(I,I_,D)
    K<sqrtD>:= QuadraticField(D);       // generates real quadratic field K = Q(Sqrt(D))
    R:= RingOfIntegers(K);      // generates ring of integers of K; every element of R is of the form a + Nu*b, where a,b are integers, Nu is defined as below
   
    if (D mod 4 eq 2) or (D mod 4 eq 3) then
        Nu:= sqrtD;
        NumericalNu:= Sqrt(D);  // the numerical approximation of Nu as a real number
    elif (D mod 4 eq 1) then
        Nu:= (1 + sqrtD)/2;
        NumericalNu:= (1 + Sqrt(D))/2;  // the numerical approximation of Nu as a real number
    end if;     // D mod 4 eq 0 is impossible since it would imply that D would be divisible by the square 4
    
    Qi:= [];    // stores < p, h_i, pi, pi_, P > for p in I, where p splits in K; h_i is an integer such that P^(h_i) = (pi) is principal; pi is an element of K generating the ideal P^(h_i) = (p)R; 
                    // pi_ is the conjugate of pi, chosen so that Abs(pi) > Abs(pi_); P is the choice of prime ideal above p in K
    Qi_:= [];   // stores < p, h_i, pi, pi_, P > for p in I_, where p splits in K; h_i is an integer such that P^(h_i) = (pi) is principal; pi is an element of K generating the ideal P^(h_i) = (p)R; 
                    // pi_ is the conjugate of pi, chosen so that Abs(pi) < Abs(pi_); P is the choice of prime ideal above p in K

    U,psi:= UnitGroup(K);   // computes the unit group, U, of the number field K, where U = {+/- u^k, k in Z}; U is generated by -1 (denoted psi(U.1)) and powers of u (denoted psi(U.2))
    if psi(U.1) eq -1 then  // ensures u is not chosen to be -1, otherwise Abs(pi) = Abs(-1*pi)
        u:= psi(U.2)[1] + Nu*psi(U.2)[2];   // writes u in the form a + Nu*b
        Numericalu:= u[1] + Sqrt(D)*u[2];   // computes the numerical approximation of pi as a real number
    else
        u:= psi(U.1)[1] + Nu*psi(U.1)[2];
        Numericalu:= u[1] + Sqrt(D)*u[2];
    end if;

    for q in I do
        t,pi0:= IsPrincipal(q[3]^(q[2]));       // determines the generator, pi, of the principal ideal P^(h_i) = (pi)R  
    
        if t eq false then      // verification that indeed P^(h_i) = (pi)R is principal; if false, there is an error in DecompositionOfPrimesXYZ2.m
            print "Something is wrong in DecompositionOfPrimesXYZ2: SplitPrime^(h_i) is not principal.";
        else
            
            pi:= pi0[1] + Nu*pi0[2];        // writes pi in the form a + Nu*b 
            NumericalPi:= pi[1] + Sqrt(D)*pi[2];    // computes the numerical approximation of pi as a real number
            pi_:= Conjugate(pi);    // computes the conjugate of pi
            NumericalPi_:= pi_[1] + Sqrt(D)*pi_[2];         // computes the numerical approximation of pi_ as a real number
        
            k:= -5;                        
            while Abs(NumericalPi) le Abs(NumericalPi_) do  // if Abs(pi) > Abs(pi_) is not already true, multiply pi by a unit to ensure this happens
                pi:= (u^k)*pi;  // update pi; note (pi)R = (u*pi)R as ideals since it is determined up to multiplication by a unit
                NumericalPi:= pi[1] + Sqrt(D)*pi[2];        // writes pi in the form a + Nu*b 
                pi_:= Conjugate(pi);        // computes the conjugate of pi
                NumericalPi_:= pi_[1] + Sqrt(D)*pi_[2];     // computes the numerical approximation of pi_ as a real number
                k:= k + 1;
                if k eq 50 then
                    k:= 2*k;
                end if;
            end while;
        end if;
            
        if (ideal<R|pi> eq q[3]^q[2]) eq false then     // verification that indeed P^(h_i) = (pi)R after updating pi; if false, there is an error in SplitPrimePropertiesXYZ2.m
            print "Something is wrong in SplitPrimePropertiesXYZ2: (pi)R does not equal SplitPrime^(h_i), i in I.";
        else
            Append(~Qi,<q[1],q[2],pi,pi_,q[3]>);
        end if;
    end for;
    
    for q_ in I_ do
        t,pi0:= IsPrincipal(q_[3]^(q_[2]));       // determines the generator, pi, of the principal ideal P^(h_i) = (pi)R  
    
        if t eq false then      // verification that indeed P^(h_i) = (pi)R is principal; if false, there is an error in DecompositionOfPrimesXYZ2.m
            print "Something is wrong in DecompositionOfPrimesXYZ2: SplitPrime^(h_i) is not principal.";
        else
        
            Pis:= [];   // stores all < NumericalPi, pi, NumericalPi_, pi_, k > such that Abs(pi) < Abs(pi_) 
            
            pi:= pi0[1] + Nu*pi0[2];    // writes pi in the form a + Nu*b 
            NumericalPi:= pi[1] + Sqrt(D)*pi[2];        // computes the numerical approximation of pi as a real number
            pi_:= Conjugate(pi);        // computes the conjugate of pi
            NumericalPi_:= pi_[1] + Sqrt(D)*pi_[2];     // computes the numerical approximation of pi_ as a real number
            
            for k in [-50..50] do
                pi:= (u^k)*pi0;         // update pi; note (pi)R = (u*pi)R as ideals since it is determined up to multiplication by a unit
                NumericalPi:= pi[1] + Sqrt(D)*pi[2];    // writes pi in the form a + Nu*b 
                pi_:= Conjugate(pi);    // computes the conjugate of pi
                NumericalPi_:= pi_[1] + Sqrt(D)*pi_[2];  
                
                if Abs(NumericalPi) lt Abs(NumericalPi_) then   // if Abs(pi) < Abs(pi_) is true, store the values in the array Pis
                    Append(~Pis, < NumericalPi, pi, NumericalPi_, pi_, k >);
                end if;
            end for;
            
            if Pis ne [] then 
                mpi, mpiIndex:= Min([Abs(pis[3]) : pis in Pis]);        // determines minimal value of Abs(pi_) such that Abs(pi) < Abs(pi_)
                pi:= Pis[mpiIndex][2];
                pi_:= Pis[mpiIndex][4];
        
            else        // Pis is empty, continue updating pi to ensure that Abs(pi) < Abs(pi_) is true
                k:= -2;
                while Abs(NumericalPi) ge Abs(NumericalPi_) do  // if Abs(pi) > Abs(pi_) is not already true, multiply pi by a unit to ensure this happens
                    pi:= (u^k)*pi0;  // update pi; note (pi)R = (u*pi)R as ideals since it is determined up to multiplication by a unit
                    NumericalPi:= pi[1] + Sqrt(D)*pi[2];        // writes pi in the form a + Nu*b 
                    pi_:= Conjugate(pi);        // computes the conjugate of pi
                    NumericalPi_:= pi_[1] + Sqrt(D)*pi_[2];     // computes the numerical approximation of pi_ as a real number
                    k:= k + 1;
                    if k eq 50 then
                        k:= 2*k;
                    end if;
                end while;
            end if;
        end if;
        
        if (ideal<R|pi> eq q_[3]^q_[2]) eq false then     // verification that indeed P^(h_i) = (pi)R after updating pi; if false, there is an error in SplitPrimePropertiesXYZ2.m
            print "Something is wrong in SplitPrimePropertiesXYZ2: (pi)R does not equal SplitPrime^(h_i), i in I.";
        else
            Append(~Qi_,<q_[1],q_[2],pi,pi_,q_[3]>);
        end if;
    end for;
        
    return Qi,Qi_;
end function;